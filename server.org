#+title: PATA Server
#+author: Hrushikesh Patwardhan

* What is it?
This is the backend of the PICT Attendance Tracker App (PATA). It will
handle data management and run an http server that provides the
information to the app.

* Dependencies
This server is written in Common Lisp (SBCL). It depends on the
following libraries:
+ ~hunchentoot~ A simple http server
+ ~ironclad~ An encryption library used to hash the passwords
+ ~flexi-streams~ A library to make handling SHA256 digests easy
+ ~cl-csv~ To read from and write to csv files
+ ~cl-json~ To convert Lisp objects into json format to send it to the
  app

The ~quicklisp~ package management system is used to load these
libraries

#+begin_src lisp
(ql:quickload :hunchentoot)
(ql:quickload "ironclad")
(ql:quickload :flexi-streams)
(ql:quickload :cl-csv)
(ql:quickload :cl-json)
#+end_src

#+RESULTS:
| :CL-JSON |

* Utils

Some utility functions

** Timestamp Function

Returns a properly formatted timestamp, according to server time. This
is placed on the attendance sheets

#+begin_src lisp
(setf path "/home/liquidcat/proj/PATA-Server/")

(defparameter *day-names*
           '("Monday" "Tuesday" "Wednesday"
	         "Thursday" "Friday" "Saturday"
	     "Sunday"))

(defun timestamp ()
  "returns current timestamp according to the server"
  (multiple-value-bind
           (second minute hour day month year day-of-week dst-p tz)
    	   (get-decoded-time)
           (format nil "~2,'0d:~2,'0d:~2,'0d ~d/~2,'0d/~d"
	    	 hour
	    	 minute
	    	 second
	    	 day
	    	 month
	    	 year)))

#+end_src

#+RESULTS:
: TIMESTAMP


** Server utils

Creates a Hunchentoot Server. 

#+begin_src lisp
(defvar *server* (make-instance 'hunchentoot:easy-acceptor :port 4242))

(defun start-server ()
  "runs the server"
  (hunchentoot:start *server*))

(defun stop-server ()
  "stops the server"
  (hunchentoot:stop *server*))

(defun restart-server ()
  "restarts the server"
  (stop-server)
  (start-server))

#+end_src

#+RESULTS:
: RESTART-SERVER


* Handlers
These are basically functions which are bound to addresses on the
server. For example,
+ The address ~<server-addr>/login~ will be bound to the function
  ~(login user pass)~.
+ When a ~GET~ request is made to the address ~<server-addr>/login~,
  this function will be called.
+ The arguments ~user~ and ~pass~ will be bound to the query
  parameters of the url
+ Consider that a ~GET~ request is made with the url:
  ~<server-addr>/login?user=acbd&pass=1234~, the function ~(login)~
  will be called with the parameters ~user = "abcd"~, ~pass = 1234~.
  Like so ~(login "abcd" "1234")~
+ The standard output ~(format nil <output>)~ of this function is then
  returned as the body of the response from the server.
  
** Upload Attendance
This handles the upload attendance request.
+ The http query parameter ~absent~ is a comma separated list of the
+ It is bound to the path ~<server-addr>/uploadAttendance~
+ Right now it simply writes the attendance to the file ~attendance~

#+begin_src lisp
(hunchentoot:define-easy-handler (say-yo :uri "/uploadAttendance") (absent)
  (setf (hunchentoot:content-type*) "text/plain")
  (with-open-file (stream (concatenate 'string path "attendance")
			  :direction :output
			  :if-exists :append
			  :if-does-not-exist :create)
    (format stream "[~a]:~a~%" (timestamp) absent))
  (format nil "done"))
#+end_src

#+RESULTS:
: SAY-YO

** Login
This handles the login request

#+RESULTS:
: ATTEMPT-LOGIN

+ This is the actual server handler
+ It is bound to the address ~<server-addr>/login~
+ It takes 2 parameters (http query parameters)
  + The username
  + The password hash
+ It returns a json formatted string which contains a property
  ~status~ which is either ~true~ or ~false~
+ It also contains an ~id~ property which contains the abbreviation of
  the teachers name if the login corresponds to a teacher

#+begin_src lisp
(defun caddddr (list)
  (car (cddddr list)))

(hunchentoot:define-easy-handler (login :uri "/login") (user pass)
  (setf (hunchentoot:content-type*) "text/plain")
  (let* ((credentials (attempt-login user pass))
	 (status (if credentials "success" "failure"))
	 (isFaculty (cadddr credentials))
	 (id (caddddr credentials))
	 (UID (car credentials)))
    (format nil (cl-json:encode-json-plist-to-string
		 `(:status ,status :isFaculty ,isFaculty :id ,id :uid ,UID)))))
#+end_src

#+RESULTS:
: LOGIN

** Schedule Handler

This handles the ~getSchedule~ request
+ This queries the database generated by the [[file:data-management.org][data-management]] part of
  the code by using the ~query-timetable~ function
+ It is bound to the route ~<server-addr>/getSchedule~
+ It takes 3 arguments (http query parameters)
  + the username ~user~
  + the password hash ~pass~
  + the scope of the query ~scope~
+ The ~scope~ is a string like
  + "KDK" - returns the weekly schedule for teacher with abbreviation KDK
  + "KDK,Tue" - returns the schedule for Tuesday for teacher KDK
  + "KDK,Wed,9:00" - returns the schedule for 9:00 AM on Wednesday for KDK

+ It returns the corresponding data from the timetable. An example of
  a return value for *scope="KDK,Mon"* would be

:   {
:       "8:00": "A10",
:       "9:00": "A10",
:       "10:15": "FE3",
:       "11:15": "FE4",
:       "13:00": "FE5",
:       "14:00": "FE6"
:   }

#+begin_src lisp
(hunchentoot:define-easy-handler (get-schedule :uri "/getSchedule") (user pass scope)
  (setf (hunchentoot:content-type*) "text/plain")
  (let ((credentials (attempt-login user pass))
	(split-scope (split-sequence:split-sequence #\, scope))) ;splits the input at commas
    (if (caddr credentials)		;only faculty will have id
	(format nil
		(cl-json:encode-json-alist-to-string
		 (query-timetable (cons (caddr credentials) split-scope)
				  *timetable*)))
	(format nil "no schedule found"))))
#+end_src

#+RESULTS:
: GET-SCHEDULE
