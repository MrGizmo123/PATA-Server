#+title: PATA Database
#+author: Hrushikesh Patwardhan

* What is it?
It is where the collection of functions relating to data storage of
the PICT Attendance Tracker App.

* Login Database

The Hash string function takes a string and returns the string
representation of the SHA256 hash of the input. This is used to hash
passwords

#+begin_src lisp
(defun hash-string (string)
  "returns the SHA256 hash of STRING as a string"
  (ironclad:byte-array-to-hex-string
   (ironclad:digest-sequence :sha256
			     (flexi-streams:string-to-octets string))))

#+end_src

#+RESULTS:
: HASH-STRING

+ The ~*logins*~ variable store the data of all the students and teachers

#+begin_src lisp
(defparameter *logins* nil)
(defparameter *current-login-UID* 0)

(defun load-logins ()
  "loads the data from the logins file"
  (setf *logins* (cl-csv:read-csv #P"logins"))
  (setf *current-login-UID* (length *logins*)))

(defun assert-logins-loaded ()
  "checks if the logins file has been loaded, if not then loads it"
  (if (not *logins*)
      (load-logins)))
#+end_src

#+RESULTS:
: ASSERT-LOGINS-LOADED



The ~add-login~ function takes a 

#+begin_src lisp

(defun add-login (user pass &key (faculty nil) (id nil))
  "hashes and stores the password in the login file"
  
  (let ((pass-hash (hash-string pass))
	(is-faculty (if faculty "true" "false")))
    
    (assert-logins-loaded)
    (nconc *logins* (list (list *current-login-UID* user pass-hash is-faculty id)))
    (incf *current-login-UID*)
    
    (with-open-file (stream (concatenate 'string path "logins")
			    :direction :output
			    :if-exists :append
			    :if-does-not-exist :create)
      (format stream "~a,~a,~a,~a~%" user pass-hash is-faculty id))))
#+end_src

#+RESULTS:
: ADD-LOGIN

+ The function ~attempt-login~ checks the ~logins~ file to see if
  there is an entry corresponding to the input ~user~ and ~pass~
+ ~pass~ is of course the hash of the password, not the actual password
+ The ~logins~ file is a csv file, it is currently formatted like so
  + Each entry has 3 parts, comma separated: ~<Name>, <Password-Hash>, <isFaculty>, <ID>~
  + When parsed by ~cl-csv~, it returns a list of lists containing,
    the entries for example are like this:
    
:     (("Student1" "skdjalskdjlefseifjlsdkjfslkdglskdjglsegilihlih" "false" "11011")  ; ID is roll no for student
:      ("Student2" "lsdkfjslkdjflseifjlsieglfdhgkjfhdkuhrgugjvhsle" "false" "12021")
:      ("Teacher1" "mioiukjrtkjfglifguldifjglsieruslidfjglsidkjufg" "true" "KDK")) ; ID is Abbreviation fir teachers

#+begin_src lisp
(defun attempt-login (user pass)
  "Checks the credentials and returns the entry of fields as a
list."
  (assert-logins-loaded)
  (let ((result))
    (loop for cred in *logins*
	do (if (and (string= (caddr cred) pass) (string= (cadr cred) user))    
	       (setf result cred)))
    result))
#+end_src

#+RESULTS:
: ATTEMPT-LOGIN

* Attendance Database

This also works on the variable ~*logins*~, it handles the attendance
data part of the dataset


** Data Import

These functions will import the data from the csv's generated from the
data provided by the college.

+ Read the source csv
+ Create entry in the ~logins~ file with some default passwd (maybe their roll no)
+ Convert the attendance data into an alist
+ wrtie the alist to the ~attendance-data~ file
+ ensure that the UID in the ~logins~ and ~attendance-data~ matches

#+begin_src lisp

					;(defparameter *attendance-data* nil)

(defun get-generic-password (entry)
  "gets a generic but unique password for each entry (eg the roll no)"
  (car entry))

(defun import-student-data (filename subjects)
  "imports the data from the college csv files"
  (let ((raw-data (cl-csv:read-csv (pathname filename))))
    (with-open-file (logins "logins" :direction :output
				     :if-exists :append
				     :if-does-not-exist :create)
      (setf *attendance-data* (nconc *attendance-data* (loop for entry in raw-data
							     do (format logins
									"~a,~a,~a,~a~%"
									(car entry)
									(hash-string (get-generic-password entry))
									(cadr entry)
									,*current-login-UID*)
							     collect (cons *current-login-UID*
									   (loop for present in (cddr entry) by #'cddr
										 for total in (cdddr entry) by #'cddr
										 for subject in subjects
										 collect `(,subject ("present" . ,present) ("total" . ,total))))
							     do (incf *current-login-UID*)))))))

#+end_src

#+RESULTS:
: IMPORT-STUDENT-DATA



* Timetable Database

#+name: KDK-timetable
|  Time | Mon | Tue  | Wed  | Thu | Fri  | Sat |
|  8:00 | A10 | FE11 | FE10 | FE3 | FE9  | FE2 |
|  9:00 | A10 | FE12 | FE11 | FE4 | FE10 | FE3 |
| 10:15 | FE3 | FE13 | FE12 | FE5 | FE11 | FE4 |
| 11:15 | FE4 | FE1  | FE13 | FE6 | FE12 | FE5 |
| 13:00 | FE5 | FE2  | FE1  | FE7 | FE13 | FE6 |
| 14:00 | FE6 | FE3  | FE2  | FE8 | FE1  | FE7 |

#+begin_src lisp :var input=KDK-timetable :results verbatim
(ql:quickload :cl-json)

(defun strip-timings (data)
  "removes the first element of each row of table to get rid of the
timings. Does the opposite of GET-TIMINGS"
  (loop for row in data
	collect (cdr row)))

(defun get-timings (data)
  "gets only the timings from input, does the opposite of STRIP-TIMINGS"
  (loop for row in (cdr data)		; cdr of data to discard the "Time" column title
	collect (car row)))

(defun transpose (data)
  "transposes the input table so that the timetable for each day is
contained in one list."
  (loop for day in (car data)
	for i from 0
	collect (loop for elem in (cdr data)
		      collect  (nth i elem))))

(defun transpose-and-label (data)
  "transposes the input table so that the timetable for each day is
contained in one list. Also labels the data for readable JSON
representation"
  (loop for day in (car data)
	for i from 0
	collect (cons day  (loop for elem in (cdr data)
				 collect (cons "time" (nth i elem))))))

(defun apply-timings (transposed-data timings)
  "Applies the timings to the transposed data. In most cases
TRANSPOSED-DATA should be output of function TRANSPOSE. TIMINGS should
be output of function GET-TIMINGS"
  (loop for day in transposed-data
	do (loop for lecture in (cdr day)
		 for timing in timings
		 do (setf (car lecture) timing)))
  transposed-data)

(defun apply-teacher-name (data teacher-name)
  "Takes output of function APPLY-TIMINGS and adds a property at the
beginning which indicates the teachers name"
  (list (cons teacher-name data)))

(defun query-timetable (keys timetable &key (test #'string=))
  "Queries the TIMETABLE recursively by using KEYS"
  (if keys
      (query-timetable (cdr keys) (cdr (assoc (car keys) timetable :test test)))
      timetable))

(setf *timetable* (apply-teacher-name (apply-timings (transpose-and-label (strip-timings input)) (get-timings input)) "KDK"))

#+end_src

#+RESULTS:
#+begin_example
(("KDK"
  ("Mon" ("8:00" . "A10") ("9:00" . "A10") ("10:15" . "FE3") ("11:15" . "FE4")
   ("13:00" . "FE5") ("14:00" . "FE6"))
  ("Tue" ("8:00" . "FE11") ("9:00" . "FE12") ("10:15" . "FE13")
   ("11:15" . "FE1") ("13:00" . "FE2") ("14:00" . "FE3"))
  ("Wed" ("8:00" . "FE10") ("9:00" . "FE11") ("10:15" . "FE12")
   ("11:15" . "FE13") ("13:00" . "FE1") ("14:00" . "FE2"))
  ("Thu" ("8:00" . "FE3") ("9:00" . "FE4") ("10:15" . "FE5") ("11:15" . "FE6")
   ("13:00" . "FE7") ("14:00" . "FE8"))
  ("Fri" ("8:00" . "FE9") ("9:00" . "FE10") ("10:15" . "FE11")
   ("11:15" . "FE12") ("13:00" . "FE13") ("14:00" . "FE1"))
  ("Sat" ("8:00" . "FE2") ("9:00" . "FE3") ("10:15" . "FE4") ("11:15" . "FE5")
   ("13:00" . "FE6") ("14:00" . "FE7"))))
#+end_example


* Student Lookup
This is the part which will construct, store, retrieve, query and
update a trie data structure containing the students names
